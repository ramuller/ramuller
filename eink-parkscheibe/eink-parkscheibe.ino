#include <DS3231.h>

#include <SPI.h>
#include <epd1in54.h>
#include <epdpaint.h>
typedef unsigned char   u8;

#include "font16x16-correct.h"

#define COLORED     0
#define UNCOLORED   1
#define CLEAR       0x55
#define MYROTATE    ROTATE_180

#define SIZE_X 2
#define SIZE_Y 5
#define DISPLAY_LINE 1
#define UPDATE_EVER_MINUTES 30
  
// unsigned char image[1024];
unsigned char image[800];
Paint paint(image, 0, 0);    // width should be the multiple of 8 
Epd epd;

#define MAXSTR  10
char pbuf[MAXSTR];  // buffer to print

u8 lastmin = 100;

// Init the DS3231 using the hardware interface
DS3231  rtc(SDA, SCL);

/**
* 8x8 monochrome bitmap fonts for rendering
* Author: Daniel Hepper <daniel@hepper.net>
*
* License: Public Domain
*
* Based on:
* // Summary: font8x8.h
* // 8x8 monochrome bitmap fonts for rendering
* //
* // Author:
* // Marcel Sondaar
* // International Business Machines (public domain VGA fonts)
* //
* // License:
* // Public Domain
*
* Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
**/

#define SERIAL_DISPLAY

// Constant: font8x8_basic
// Contains an 8x8 font map for unicode points U+0000 - U+007F (basic latin)

typedef unsigned char   u8;


#if 0
const u8 font_map[] = {
    8, 8,
    0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00, // U+0030 (0)
    0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00, // U+0031 (1)
    0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00, // U+0032 (2)
    0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00, // U+0033 (3)
    0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00, // U+0034 (4)
    0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00, // U+0035 (5)
    0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00, // U+0036 (6)
    0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00, // U+0037 (7)
    0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00, // U+0038 (8)
    0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00, // U+0039 (9)
    0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00, // U+003A (:)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // U+0020 (space)
};
#endif

#if 0
#include<avr/pgmspace.h>
const u8 font_map[] PROGMEM = {
    16, 16,
    0x00,0x00,0x00,0x00,0xf0,0x0f,0x38,0x1c,0x38,0x1e,0x38,0x1f,0x38,0x1f,0xb8,0x1d,0xb8,0x1d,0xf8,0x1c,0xf8,0x1c,0x78,0x1c,0x38,0x1c,0xf0,0x0f,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x80,0x01,0x80,0x01,0xc0,0x01,0xf8,0x01,0xf8,0x01,0xc0,0x01,0xc0,0x01,0xc0,0x01,0xc0,0x01,0xc0,0x01,0xc0,0x01,0xf8,0x0f,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xf0,0x07,0x38,0x0e,0x38,0x1c,0x00,0x1c,0x00,0x0e,0x00,0x07,0x80,0x03,0xc0,0x01,0xe0,0x00,0x70,0x1c,0x38,0x1c,0xf8,0x1f,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xf0,0x07,0x38,0x0e,0x38,0x1c,0x00,0x1c,0x00,0x0e,0xc0,0x03,0xc0,0x03,0x00,0x0e,0x00,0x1c,0x38,0x1c,0x38,0x0e,0xf0,0x07,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x07,0xc0,0x07,0x60,0x07,0x30,0x07,0x18,0x07,0xf8,0x1f,0xf8,0x1f,0x00,0x07,0x00,0x07,0x00,0x07,0xc0,0x1f,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xf8,0x1f,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0xf8,0x07,0xf8,0x0f,0x00,0x1e,0x00,0x1c,0x38,0x1c,0x38,0x0e,0xf0,0x07,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xc0,0x07,0xe0,0x00,0x70,0x00,0x38,0x00,0x38,0x00,0xf8,0x0f,0xf8,0x1f,0x38,0x1c,0x38,0x1c,0x38,0x1c,0x38,0x1c,0xf0,0x0f,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xf8,0x3f,0x38,0x38,0x38,0x38,0x38,0x38,0x00,0x38,0x00,0x1c,0x00,0x0e,0x00,0x07,0x80,0x03,0xc0,0x01,0xc0,0x01,0xc0,0x01,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xf0,0x0f,0x38,0x1c,0x38,0x1c,0x38,0x1c,0xf8,0x1c,0xe0,0x07,0xe0,0x07,0x38,0x1f,0x38,0x1c,0x38,0x1c,0x38,0x1c,0xf0,0x0f,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xf0,0x0f,0x38,0x1c,0x38,0x1c,0x38,0x1c,0x38,0x1c,0xf8,0x1f,0xf0,0x1f,0x00,0x1c,0x00,0x1c,0x00,0x0e,0x00,0x07,0xe0,0x03,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x01,0xc0,0x01,0xc0,0x01,0x00,0x00,0x00,0x00,0xc0,0x01,0xc0,0x01,0xc0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
#endif

#if 0
const u8 font_map[] = {
    16, 8,
    0x00,0x00,0x00,0x1E,0x33,0x37,0x37,0x33,0x3B,0x3B,0x33,0x1E,0x00,0x00,0x00,0x00,/*"0",16*/
    0x00,0x00,0x00,0x0C,0x1C,0x7C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x00,0x00,0x00,0x00,/*"1",17*/
    0x00,0x00,0x00,0x3C,0x66,0x66,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00,0x00,0x00,0x00,/*"2",18*/
    0x00,0x00,0x00,0x3C,0x66,0x66,0x06,0x1C,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,/*"3",19*/
    0x00,0x00,0x00,0x30,0x30,0x36,0x36,0x36,0x66,0x7F,0x06,0x06,0x00,0x00,0x00,0x00,/*"4",20*/
    0x00,0x00,0x00,0x7E,0x60,0x60,0x60,0x7C,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00,/*"5",21*/
    0x00,0x00,0x00,0x1C,0x18,0x30,0x7C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,/*"6",22*/
    0x00,0x00,0x00,0x7E,0x06,0x0C,0x0C,0x18,0x18,0x30,0x30,0x30,0x00,0x00,0x00,0x00,/*"7",23*/
    0x00,0x00,0x00,0x3C,0x66,0x66,0x76,0x3C,0x6E,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,/*"8",24*/
    0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3E,0x0C,0x18,0x38,0x00,0x00,0x00,0x00,/*"9",25*/
    0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x00,0x00,0x00,0x1C,0x1C,0x00,0x00,0x00,0x00/*":",26*/   
};
#endif

typedef enum {
  white = '#',
  black = ' ',
  red = 'X'
} color;

void setup() {
  //Initialize serial and wait for port to open:
  // Serial.begin(9600);
  Serial.begin(57600);
  //Â Serial.begin(1200);
  // Serial.begin(19200);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  if (epd.Init(lut_full_update) != 0) {
      Serial.print("e-Paper init failed");
      return;
  }
  paint.SetRotate(MYROTATE);
  // clearScreen();
  // Initialize the rtc object
  rtc.begin();
  // The following lines can be uncommented to set the date and time
#if 0
  rtc.setTime(21,12, 00);     // Set the time to hh:mm:ss (24hr format)
  rtc.setDate(06, 11, 2018);   // Set the date to day, month, year
  rtc.setDOW();     // Set Day-of-Week to automatic
#endif

}

static void render(const u8 *fs, int ord, int column, int line)
{
  // int w = fs[1];
  // int h = fs[0];
  int w = pgm_read_byte(&fs[1]);
  int h = pgm_read_byte(&fs[0]);
  int x, y, b;
  int px,py;   
  int pixel;
  color c;
  int einkc;
  const u8        *bm = &fs[2];

  paint.SetWidth(w * SIZE_X);
  paint.SetHeight(h * SIZE_Y);
  paint.Clear(COLORED);

  // Serial.println(ord);
  for(y = 0; y < h; y++){
    for(py = 0; py < SIZE_Y; py++){
      for(b = (w/8) -1; b >= 0; --b){
        for(x = b*8; x < (b*8) + 8; x++){
          pixel = w * ord * h + y * w + x;
          c = bm[(pixel / 8) + 0] & (1 << (x % 8)) ? white : black;
          einkc = pgm_read_byte(&bm[(pixel / 8) + 0]) & (1 << (x % 8)) ? COLORED : UNCOLORED;
          // einkc = bm[(pixel / 8) + 0] & (0x80 << (x % 8)) ? COLORED : UNCOLORED;
          for(px = 0; px < SIZE_X; px++){
            paint.DrawPixel(x * SIZE_X + px, y * SIZE_Y + py, einkc);
          }
        }
      }
      epd.SetFrameMemory(paint.GetImage(), column * w * SIZE_X + 20, line * SIZE_Y * h, paint.GetWidth(), paint.GetHeight());
      // Serial.println("");
    }
  }
}

static string2ascii(u8 * s)
{
  int i = 0;

  while(s[i] != '\0'){
   Serial.print(i);
   Serial.print(" : ");
   Serial.println(s[i]);
   i++;
  }
  Serial.println("#########################");
}

void clearScreen()
{
  /** 
   *  there are 2 memory areas embedded in the e-paper display
   *  and once the display is refreshed, the memory area will be auto-toggled,
   *  i.e. the next action of SetFrameMemory will set the other memory area
   *  therefore you have to clear the frame memory twice.
   */
  
  epd.ClearFrameMemory(CLEAR);   // bit set = white, bit reset = black
  epd.DisplayFrame();
  epd.ClearFrameMemory(CLEAR);   // bit set = white, bit reset = black
  epd.DisplayFrame();
    
}

// Day Of Week Sunday 0 ... Saturday 6
int dow(Time *ti)

{ 
  if(ti->dow == SUNDAY)
    return 0;
  return ti->dow;
}

static myprint(char *s, int num)
{
  Serial.print(s);
  Serial.println(num);
}

uint8_t dst(Time *t)
{
  uint8_t dst = 0; // Normal time
  if(t->mon < 10 && t->mon > 3)  // summer time anyway
    dst = 1;
  else if(t->mon == 3 && (t->date + t->dow > 30)) // After last Sunday in March
    dst = 1;
  else if(t->mon == 10 && (t->date  - dow(t) < 24)) // Before last Sunday in Oct
    dst = 1;
  myprint("Last DST day ", t->date - dow(t));
  return dst;
}

void rotateString()
{
  int i;
  char dbuf[MAXSTR];  // buffer to display
  int length = strlen(pbuf);

  Serial.println(length);

  if(MYROTATE == ROTATE_180){
    strcpy(dbuf, pbuf);
    strcpy(pbuf, dbuf);
    for(i = 0; i < length; i++)
      pbuf[i] = dbuf[length - i - 1];
  }
}

void printstr(u8 x, u8 y)
{
  int positionInString = 0;
  
  rotateString();
  
  // x++;
  Serial.print("printscr : ");
  
  while (pbuf[positionInString] != '\0'){
      render(font_map, pbuf[positionInString] - ' ', x + positionInString, y);
      positionInString++;
  }
  return;
  Serial.println();
}

void print_time(Time *t)
{
  myprint("Hour : ", t->hour);
  myprint("min : ", t->min);
}

void loop() {
  int i, j;
  color c;
  
  Time t = rtc.getTime();
  // print_time(&t);
  // Daylight saving
  // t.hour = (t.hour + dst(&t)) % 24;
  // print_time(&t);
  if(lastmin != t.min / UPDATE_EVER_MINUTES){
    lastmin = (t.min / UPDATE_EVER_MINUTES);
    epd.ClearFrameMemory(CLEAR);
    if((lastmin + 1) % (60 / UPDATE_EVER_MINUTES) == 0)
      t.hour++;
    if(t.hour == 0)
      t.hour = 0;
    snprintf(pbuf, MAXSTR - 1, "%02d:%02d", t.hour, ((lastmin + 1) % (60 / UPDATE_EVER_MINUTES)) * UPDATE_EVER_MINUTES);
    printstr(0, DISPLAY_LINE);
    Serial.println(lastmin);
    epd.DisplayFrame();
  }
  
  // Send time  tstr = rtc.getTimeStr();
  Serial.println(rtc.getTimeStr());

  delay(2000); 
  
}
